От
11.10.2023

Получаем XLS файлы с сайта Политеха, разбираем их и сохраняем в структурированную базу данных.

Для парсинга XLS (не XLSX !) в питоне существует библиотека xlrd.


поехали!


Наша задача: получить полные данные о том:
	 какие группы, какие аудитории, в какое время, и кто проводит.
	 Кроме того, у каждого дня есть дата, месяц и номер недели (1, 2)

	Сохранить структурированном виде.
	В дальнейшем, может быть, мы захотим исправлять сокращённые названия предметов и имена преподавателей.

Соображение о подходе к программированию.

	Наши таблицы в политехе составляются вручную людьми, поэтому в них очень много различных отклонений от "стандарта".
	Идея в том чтобы создать такой парсер, который смог бы поддерживать не-программист (никто не знает, ЧТО придумают в учебном отделе через год или два).

	Предлагается сделать отдельный документ с небольшими шаблонами структурных кусков таблиц (ячеек для дисциплин), которые логически завершены и понятны человеку, и заставить парсер работать строго по этим шаблонам.
	При изменении элементов оформления в таблицах, всё что нужно будет сделать - это открыть шаблон и внести туда новый вариант форматирования, после чего парсер снова станет работать на 100%.

Ключевая идея разбора таблиц.

	Главную информация о структуре таблицы несут границы между ячейками, которые группируют их.
	Большое количество ячеек является объединёнными, и это неплохой признак для обнаружения элементов форматирования.

	Некоторые ячейки являются специальными, то есть несут особый смысл/роль. Например, это имена дней недели, названия месяцев, и граница - пустая строка между неделями (иногда там написано "2 неделя").
	От этих ячеек можно отталкиваться при разборе структуры большой таблицы.
	Полезно различать их по типам.

	Данные в таблице структурированы визуально, то есть, если одна ячейка находится напротив другой (по вертикали либо по горизонтали), то они, вероятно, связаны.
	Недостающую информацию можно получать, проходя "ладьёй" к ячейке нужного типа, и так сколько нужно раз.

	Типы ячеек будем определять по их содержимому и взаимному расположению.


Детали, замечания и подробности.

	Как обнаружилась при исследовании, граница ячеек может принадлежать только одной ячейке из двух, поэтому для адекватной работы с границами нужно проставлять границу обеим смежным ячейкам.

	Лекционные занятия частенько распространяются на несколько групп (по горизонтали).
		В связи с этим, шаблоны должны иметь возможность растягиваться по горизонтали.

	Некоторые занятия, как физическая культура, могут иметь общее название, но разных преподавателей в своих ячейках.
		В связи с этим нужно предусмотреть возможность ссылаться на растянутое название из нерастянутой ячейки.

	Структуры таблиц заметно различаются для разных факультетов и видов обучения.
	Например, в ВН_Магистратура_ЭТ-1в можно найти таблицу, у которой день недели слева от дней месяца, а не справа.
	Расписание в аспирантуре наверху имеет не группы, а предметы.
	Расписания консультаций внешне похожи на обычное расписание, но там нет времени и часов в структурном виде, - они пишутся внутри самой ячейки цифрами.
	Расписание НАЧИТКИ, например, имеет принципиально другую структуру.

	Название предмета/дисциплины чаще всего даётся заглавными буквами и помещается в отдельный объединённой ячейке.
	Но иногда название делится на несколько строк (ячеек).
	Иногда к названию добавляют дополнительную информацию, например, номер группы (в аспирантуре) и другое (всё это разделяется пробелами в рамках текста одной ячейки).

	вместо аудитории в элективных дисциплинах может стоять название в компании, в которой проводятся занятия ("ООО Лукойлинжиниринг" или "ПермНИПИнефть" -  причём на отдельных строках).

	В заголовке колонки таблицы может быть перечислено несколько групп, при этом общая часть может быть опущена: "ЭУЗ-581, 582,583" (см. ЗН_ФПИК 5 курс консультации).

	Все существенные изменения/коррективы обычно обозначаются в таблицах красным цветом.
	К примеру, перенос часов, а также перенос аудитории на конкретную дату.

	Выцеплять данные из текста ячеек предполагается регулярками, с использованием именованных захватывающих групп.




Пополняемый список всего того, что может относиться к элементу расписания:

обязательные поля:

	* дисциплина
	* группа / группы
	* учебные часы дня (или астрономическое время начала/конца занятия)
		(!) учебные часы могут быть написаны на ячейке, если её местоположение место занято и не соответствует им.
	* даты (день и месяц)
	* аудитория / аудитории
	* преподаватель / преподаватели (может быть пустым или стоять знаки "???"; могут быть указаны в разных ячейках или в одной через запятую)
		-> Несколько преподавателей и аудиторий могут быть сопоставлены друг другу (например, на иностранном языке).

не обязательные поля (но должны быть сохранены, если присутствуют; другими словами, шаблон может их ожидать, но если их не будет в реальной таблице,  это не нарушит применение шаблона)

	* фактические (явные) даты проведения (если занятие проводится раз в месяц, то даты указаны прямо в ячейке)
	* подгруппа
	* вид занятия - практика лекция лаба
	* количество часов занятия (возможно, избыточная информация)
	* признак дистанционного занятия
	* признак элективной дисциплины (может быть написано вне ячейки - снаружи)
	* жёлтый фон, обозначающий Тракторный район
	* другая информация (например, ссылка на зум)





[Устарело>>>]
обозначение сопоставления ячеек (вертикали или по горизонтали)

A <=> B  		занимают один и тот же диапазон (равны в этом измерении)
A >=  B  		A может быть шире, чем B, B полностью укладывается в диапазон A
A  =< B  		A может быть уже, чем B, A полностью укладывается в диапазон B

Возможно, тоже пригодятся:
A  >  B  		A должна быть шире, чем B, B полностью укладывается в диапазон A
A  <  B  		A должна быть уже, чем B, A полностью укладывается в диапазон B
A  --  B  		A и B имеют пересекающиеся диапазоны
[<<<Устарело]



Виды пространственных соотношений двух ячеек (в одном измерении -- в горизонтальной либо вертикальной проекции):

		--- снаружи ---

1) alpha << beta		на удалении, без примыкания
1) alpha >> beta		на удалении, без примыкания
1) alpha |1+| beta		на удалении, без примыкания

2) alpha | beta  		примыкают друг к другу краями
2) alpha |0| beta  		примыкают друг к другу краями


3) alpha || beta  		примыкают c возможностью отдаления
3) alpha |0+| beta  	примыкают c возможностью отдаления
3) alpha |*| beta  	примыкают c возможностью отдаления
3) !!! alpha > beta  	примыкают c возможностью отдаления
3) alpha >| beta  	примыкают c возможностью отдаления
3) alpha |< beta  	примыкают c возможностью отдаления
3) !!! alpha < beta  	примыкают c возможностью отдаления
3) alpha >|< beta  	примыкают c возможностью отдаления


4) alpha |2| beta  	находятся на расстоянии 2 ячейки
4) alpha |0..2| beta  	находятся на расстоянии не более 2 ячеек



		--- внутри ---

[ alpha ] beta 			alpha внутри beta, без доп. ограничений

[| alpha |] beta 		alpha и beta имеют совпадающие стенки (равны, накладываются)
alpha === beta 			alpha и beta имеют совпадающие стенки (равны, накладываются)

[<<alpha>>] beta  		alpha внутри beta, не примыкая к стенкам beta

alpha [<< beta >>]		beta внутри alpha, не примыкая к стенкам alpha

[ alpha >>] beta 		alpha внутри beta, примыкая к левой стенке beta обязательно, но не к правой

[0| alpha |0+] beta 	alpha внутри beta, примыкая к левой стенке beta обязательно, к правой - опционально

(x!)   alpha [< beta >]		beta внутри alpha, может примыкать к обеим стенкам alpha

[2+| alpha |2+] beta 	alpha внутри beta, расстояние до обеих стенок beta не менее 2



============

10.11.2023

Обсуждение Грамматики с Другом.


Михаил 1:19
Привет!
я всю неделю думал и проектировал,
Вот что получилось на уровне лексера (это уже работает):
https://github.com/den1s0v/vstu_xls/blob/main/cnf/cell_types.yml
и на уровне парсера (это только наброски, ещё не работает)
https://github.com/den1s0v/vstu_xls/blob/main/cnf/grammar_root.yml
Грамматика для парсера во многом вдохновлена твоей нотацией.
Я подумал — зачем изобретать DSL, если можно использовать обычный язык разметки (всё равно оно будет разобрано в JSON или подобную структуру)
(поэтому использую YAML, он тоже достаточно легкочитаем)

Макс 20:27
В принципе прикольно, мне нравится, действительно похоже на то что я предлагал
Мне нравится как ты в итоге сделал контроль отступов, но мне еще интересно как ты собираешься контролировать положение относительно outer элементов, и собираешься ли (если да то как) задавать в некотором родительском элементе ограничения на положение дочерних элементов относительно друг друга
потому что когда ты мне в прошлый раз сказал про отступы я в основном на этом застопорился
Потому что теоретически, если ты хочешь иметь полный контроль над структурой, можно захотеть сказать (например) "ячейка пары существует, если ее дочерняя ячейка названия находится на 2 клетки выше дочерней ячейки преподавателя" - и вот как сделать для этого удобный лаконичный синтаксис, я в тот раз особо не придумал
ну либо ты можешь сказать что настолько сильный контроль не нужен)

Михаил 21:31
Насчёт контроля взаимного расположения дочерних элементов — да, конечно, я собираюсь это проверять, просто не придумал ещё, как это красиво внести в нотацию (то, о чём ты говоришь).
Я собираюсь довести контроль до возможности полной жёсткости структуры, ибо такая необходимость может возникнуть.
вот это я тоже хочу взять, но ещё не прорабатывал подробно:
"- При равнении на структуры типа Row и Col из других структур, можно указать сколько их элементов текущая структура занимает."
у нас бывают забавные ситуации, когда лекция может охватывать как несколько групп так и "менее одной"
[img]
Вот здесь авторы таблица скрыли лишние столбцы (А мы их открыли назад), видимо, для недостающей группы, чтобы не переносить все группы справа.
получается, занятия равняются на часть группы

Макс 21:36
Какого только кошмара в этих расписаниях не бывает
Никакой формализации)

Михаил 21:36
поэтому как-то интересно при равнении объединить для перечисления и "внутри одной", и "несколько целых"

Михаил 21:41
Давай подумаем вместе.
Для указания внутренних ограничений достаточно ли только расстояния между элементами, то есть хватит ли таких полей (для пары элементов) ?:
gap: ...
vertical gap: ...
horizontal gap: ...
думаю нет, надо ещё выравнивание учитывать

Макс 21:48
Ну я это вижу примерно так: вертикальная грань одной ячейки отстоит слева/справа от вертикальной грани другой ячейки на N клеток
Ну и аналогично с горизонтальными
И получается миллион таких ограничений

Михаил 21:49
Выровнены левому краю
alpha.left == beta.left
я думаю, тут уже проще обычными координатами и неравенствами/равенствами записывать

Макс 21:51
А лево/право отличать как больше/меньше?

Михаил 21:51
alpha.left <= beta.left
alpha.left >= beta.left
alpha.left <> beta.left — Смещение в любую сторону
вопрос, — если допустим, надо минимальный отступ задать, или максимальный
я думал ещё по поводу такой нотации
alpha | L-0..2-L T-1..2-B | beta

Михаил 21:54
 >>
я думал ещё по поводу такой нотации alpha | L-0..2-L T-1..2-B | beta
сможешь догадаться, что здесь имеется в виду ?)

Макс 21:54
Да, типа левые стороны от 0 до 2, верх и низ от 1 до 2
Но мне не кажется это удобным)

Михаил 21:55
верно, значит, beta выше alpha
Я задумал эту запись так, чтобы можно было все отношения между двумя элементами в одном месте держать
а так — да, согласен, немного путано

Макс 21:57
Мне вот это больше нравится
Могу предложить указывать промежутки типа
a.left <{0, 2}< b.left
(Как кванторы в регулярках)
Ну либо по аналогии
a.left <0..2< b.left
Пересланные телеграммы


сегодня в 21:52
alpha.left <= beta.left
alpha.left >= beta.left
alpha.left <> beta.left — Смещение в любую сторону
вопрос, — если допустим, надо минимальный отступ задать, или максимальный

Михаил 21:58
 >>
Мне вот это больше нравится Могу предложить указывать промежутки типа a.left <{0, 2}< b.left (Как кванторы в регулярках) Ну либо по аналогии a.left <0..2< b.left
пожалуй да, такое мне нравится

можно ли сказать, что все эти
.left .right .top .bottom
в записи тебя не смущают?

Макс 22:00
Ну разве что если оно будет конфликтовать с обращением к полям
Но с этим можно просто любой любой другой разделитель использовать
А так да, не смущает в принципе

 >>

Михаил 22:01
Вряд ли будет конфликтовать
можно сделать синтаксический сахар вроде
left of alpha

Макс 22:03
 >>
Вряд ли будет конфликтовать
Я визуально имею в виду если что
Что чисто на взгляд a.left может быть и поле и сторона)

Но мб для сторон можно сделать a:left
Но это мелочи в принципе)

Михаил 22:04
понял тебя)
внутренние ограничения обсудили
Насчёт сопоставления со множеством внешних.
item:
. . outer:
. . . . groups: subarray of group | within

Макс 22:11
Ну интересно
В принципе это похоже на то что я предлагал

Михаил 22:12
Да, я с твоего и взял)

Макс 22:12
Но тут вопрос в том что это как будто не очень соответствует твоим пожеланиям о полном контроле

Макс 22:14
 >>
Мне вот это больше нравится Могу предложить указывать промежутки типа a.left <{0, 2}< b.left (Как кванторы в регулярках) Ну либо по аналогии a.left <0..2< b.left
Вообще, вот такая нотация позволяет полный контроль вообще над всем
Но тут надо найти золотую середину

Михаил 22:14
ну... насчёт внешних, я не думаю, что надо контролировать с точностью до координаты, хотя никто не мешает добавить и ограничения в числах

Михаил 22:15
 >>
Вообще, вот такая нотация позволяет полный контроль вообще над всем
согласен, можно в секцию outer: поместить такие же неравенства с диапазонами

Макс 22:17
Ну имхо тут важно то чтобы скореллировать простые ограничения (типа как subarray), с вот этими сложными
Скорее всего имеет смысл сделать так что простые ограничения как то можно выразить через сложные
Но тут нужно прям методически продумать
Я пока сходу не могу)

Михаил 22:19
 >>
Ну имхо тут важно то чтобы скореллировать простые ограничения (типа как subarray), с вот этими сложными Скорее всего имеет смысл сделать так что простые ограничения как то можно выразить через сложные
конечно, да, высокоуровневые ограничения должны выражаться через низкоуровневые
subarray :::
this.left == arr[0].left
this.right == arr[-1].right
Смысл примерно такой

Макс 22:21
Ну и ещё просто мысль - вот эти низкоуровневые ограничения нужно будет прям жёстко валидировать, ибо с их помощью можно прям любую невозможную конфигурацию написать

Михаил 22:22
within :::
this.left <= other.left
this.right >= other.right
Вообще да, можно и обычными ограничениями задать невозможную комбинацию
а в комбинации с высокоуровневыми это ещё проще

Макс 22:23
Да

Михаил 22:25
По-моему, продуктивно поработали сегодня))

Макс 22:35
Согласен)


